# Design Patterns in ReccarmendFullStack Project

This document discusses two design patterns suitable for this project, each tied to specific functional or non-functional requirements.

The **Strategy Pattern**, implemented through Python's Abstract Base Class (ABC) interface, addresses the functional requirement that the system must scrape car listings from multiple websites (CarPages.ca, AutoTrader, and future websites) to populate the database. This pattern is demonstrated in `Webscraping/scraper_interface.py`, where an abstract `Scraper` class defines a contract that all concrete scrapers must implement, enabling the `ScrapingController` to work with any scraper through a unified interface. When a new car listing website needs to be supported, developers only need to create a new class that inherits from `Scraper` and implements the required methods, then register it in the controller's dictionary without modifying existing code. This design fulfills the functional requirement by making the system extensible: different websites have different HTML structures and data formats, but the Strategy Pattern encapsulates each website's unique scraping algorithm in its own class while maintaining a consistent interface. By following the Open/Closed Principle, the Strategy Pattern allows the system to be open for extension but closed for modification, making it trivial to add new car listing sources as business requirements evolve.

The **MVC (Model-View-Controller) Architecture Pattern** addresses the non-functional requirement of maintainability, which states that the system must allow developers to modify, update, or extend individual components (frontend UI, backend API, or database schema) without affecting other parts of the system. This pattern enforces strict separation of concerns by dividing the application into three independent layers: the Model (`Database_Model_Connection/`) handles all data persistence and database operations with Supabase, the View (`View/`) contains all React/TypeScript UI components and user interface logic, and the Controller (`Controller/api_server.py`) orchestrates business logic and coordinates between the Model and View through REST API endpoints. This separation directly supports the maintainability requirement by ensuring that when a developer needs to update the database schema, they only modify the Model layer without touching the View or Controller code; similarly, UI changes like redesigning the car card component only affect the View layer, while business logic changes such as modifying the AI search algorithm are isolated to the Controller layer. The MVC pattern's clear boundaries prevent cascading changes across the system, allowing the frontend team to update React components without understanding Flask backend code, and enabling the backend team to optimize database queries without affecting the frontend as long as the API contract remains consistent. The MVC pattern ultimately makes the codebase easier to maintain, debug, and extend as the project grows, fulfilling the non-functional requirement of maintainability by providing a structured approach that minimizes the impact of changes to any single component.
